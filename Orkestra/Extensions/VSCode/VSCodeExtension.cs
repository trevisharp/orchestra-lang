/* Author:  Leonardo Trevisan Silio
 * Date:    28/06/2023
 */
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO.Compression;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace Orkestra.Extensions.VSCode;

/// <summary>
/// Represents a VSCode Extension.
/// </summary>
public class VSCodeExtension : Extension
{
    List<VSCodeContribute> contributes = [];
    List<JSContribute> jscontributes = [];
    public IEnumerable<VSCodeContribute> Contributes => contributes;
    public IEnumerable<JSContribute> JSContributes => jscontributes;
    
    public void Add(VSCodeContribute contribute)
    {
        if (contribute is null)
            return;
        
        contributes.Add(contribute);
    }

    public void Add(JSContribute contribute)
    {
        if (contribute is null)
            return;
        
        jscontributes.Add(contribute);
    }

    public virtual void LoadDefaultContributes(ExtensionArguments args)
    {
        foreach (var lang in args.Languages)
        {
            Add(new LanguageContribute(lang));
            Add(new GrammarContribute(lang));
            Add(new AutoCompleteJSContribute(lang));
        }
    }

    public override async Task Generate(ExtensionArguments args)
    {
        Verbose.Info("Generating VSCode Extension...", 1);
        Verbose.NewLine();

        LoadDefaultContributes(args);

        var path = CreateTempFolder();
        Verbose.Info($"Temp directory created on {path}.", 3);

        var extPath = InitExtensionDirectory(path);

        await AddPackageJson(extPath, args);
        await AddReadme(extPath, args);
        await AddContributes(extPath, args);
        await AddExtensionJS(extPath, args);
        await AddChangeLog(extPath, args);
        
        var finalFile = args.Name + ".vsix";
        DeleteFileIfExists(finalFile);
        Zip(path, finalFile);

        DeleteFolderIfExists(path);
        Verbose.Info($"Temp directory removed from {path}.", 3);
    }
    
    public override async Task Install(ExtensionArguments args)
    {
        var finalFile = args.Name + ".vsix";
        await Generate(args);
        Install(finalFile);
        DeleteFileIfExists(finalFile);
    }

    static string InitExtensionDirectory(string dir)
    {
        var extensionPath = Path.Combine(dir, "extension");
        Directory.CreateDirectory(extensionPath);
        return extensionPath;
    }

    async Task AddPackageJson(string dir, ExtensionArguments args)
    {
        const string file = "package.json";
        var sw = OpenWriter(dir, file);

        var name = args.Name;

        await sw.WriteLineAsync(
            $$"""
            {
                "name": "{{name}}",
                "displayName": "{{name}}",
                "publisher": "Orkestra",
                "description": "A autogenerated Orkestra VSCode extension for {{name}}.",
                "version": "1.0.0",
                "engines": {
                    "vscode": "^1.89.0"
                },
                "categories": [
                    "Programming Languages"
                ],
                "activationEvents": [],
                "main": "./extension.js",
                "contributes": {
            """
        );

        var contributeGroups = 
            from c in contributes
            group c by c.Type;
        var contributeGroupsArray = 
            contributeGroups.ToArray();

        for (int i = 0; i < contributeGroupsArray.Length; i++)
        {
            var g = contributeGroupsArray[i];
            var contName = g.Key.ToString().ToLower();
            await sw.WriteLineAsync($"\t\t\"{contName}\": [");

            foreach (var contribute in g)
                await sw.WriteLineAsync("\t\t" + 
                    contribute.Declaration
                        .Replace("\n\r", "\t\t")
                        .Replace("\n", "\t\t")
                );

            if (i < contributeGroupsArray.Length - 1)
                await sw.WriteLineAsync("\t],");
            else await sw.WriteLineAsync("\t]");
        }

        await sw.WriteAsync(
            """
                },                
                "scripts": {
                    "lint": "eslint .",
                    "pretest": "npm run lint",
                    "test": "vscode-test"
                },
                "devDependencies": {
                    "@types/vscode": "^1.89.0",
                    "@types/mocha": "^10.0.6",
                    "@types/node": "18.x",
                    "eslint": "^8.57.0",
                    "typescript": "^5.4.5",
                    "@vscode/test-cli": "^0.0.9",
                    "@vscode/test-electron": "^2.4.0"
                }
            }
            """
        );

        sw.Close();
    }

    async Task AddContributes(string dir, ExtensionArguments args)
    {
        foreach (var contribute in contributes)
            await contribute.GenerateFile(dir);
    }

    async Task AddReadme(string dir, ExtensionArguments args)
    {
        const string file = "README.md";
        var sw = OpenWriter(dir, file);

        await sw.WriteLineAsync(
            $"""
            # {args.Name}
            
            A autogenerated VSCode extension of {args.Name} using Orkestra Framework.
            
            ## Features
            """
        );

        var contributeGroups = 
            from c in contributes
            group c by c.Type;

        foreach (var g in contributeGroups)
        {
            await sw.WriteLineAsync($"### {g.Key}\n");
            foreach (var cont in g)
                await sw.WriteLineAsync(cont.Documentation);
            await sw.WriteLineAsync();
        }

        sw.Close();
    }

    async Task AddExtensionJS(string dir, ExtensionArguments args)
    {
        const string file = "extension.js";
        var sw = OpenWriter(dir, file);

        var js = new StringBuilder();

        foreach (var jscontribute in jscontributes)
        {
            js.AppendLine(
                jscontribute.JSCode.Replace("\n", "\n\t")
            );
        }

        await sw.WriteAsync(
            $$"""
            const vscode = require('vscode');

            function activate(context) {
            {{js}}
            }

            function deactivate() {}

            module.exports = {
                activate,
                deactivate
            }
            """
        );

        sw.Close();
    }

    static async Task AddChangeLog(string dir, ExtensionArguments args)
    {
        const string file = "CHANGELOG.md";
        var sw = OpenWriter(dir, file);

        await sw.WriteLineAsync("## Version 1.0.0");
        await sw.WriteLineAsync();
        await sw.WriteLineAsync("All elements auto generated by Orkestra framework.");

        sw.Close();
    }

    static void Zip(string directorySource, string destinationPath)
        => ZipFile.CreateFromDirectory(directorySource, destinationPath);

    static void Install(string extensionPath)
    {
        var startInfo = new ProcessStartInfo {
            WindowStyle = ProcessWindowStyle.Hidden,
            FileName = "cmd.exe",
            Arguments = $"/C code --install-extension {extensionPath}"
        };

        var process = new Process {
            StartInfo = startInfo
        };

        Verbose.NewLine();
        Verbose.Info("Visual Studio Code Output:");
        Verbose.NewLine();
        process.Start();
        process.WaitForExit();
    }

    static StreamWriter OpenWriter(string folder, string file)
    {
        var path = Path.Combine(folder, file);
        var sw = new StreamWriter(path);
        return sw;
    }

    static string CreateTempFolder()
    {
        var path = GetRandomTempFolder();
        while (Directory.Exists(path))
            path = GetRandomTempFolder();

        InitOrResetFolder(path);
        return path;
    }

    static string GetRandomTempFolder()
    {
        var temp = Path.GetTempPath();
        var guid = Guid.NewGuid().ToString();
        var path = Path.Combine(temp, guid);
        return path;
    }

    static void InitOrResetFolder(string path)
    {
        DeleteFolderIfExists(path);
        Directory.CreateDirectory(path);
    }

    static void DeleteFileIfExists(string path)
    {
        if (!File.Exists(path))
            return;
        
        File.Delete(path);
    }

    static void DeleteFolderIfExists(string path)
    {
        if (!Path.Exists(path))
            return;

        var dir = new DirectoryInfo(path);
        dir.Delete(true);
    }
}